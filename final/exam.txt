/* You will place all the answers for your exam in this file. Please be sure to label
each question clearly, so there is absolutely no possibility we will miss that you've
answered a question. Please do not place your name anywhere in this file.

After you have completed the exam, edit the file policy.txt, and attest that
you have followed the rules for the exam by writing, "I have I have neither
given nor received help on this exam and have followed the rules as stated."
Then type your name beneath it, indicating compliance. */

1. Data Representation
A 2^16
B 2^8
C 1024
D 5
E 65535
F 4096
G 16
H 4
I 188
J -67
=-=-=-=-=-=
2. Memory Layout
A 2
B 6
C 7*
D 7*
E 3
F 5
G 2
H 2
I 3
J 7*
=-=-=-=-=-=
3. Pot Pourri
A 0xCAFEF00D746163
B 0xD0CF11E9
C 0x8C1B01C
D 0x11
E 0x59
F 2047
G Yes
H 2
I F
J T
K 3
L 3
M 4
N 0xACE0*
O 0x9ABCDEF0
P wait
Q pipe
R waitpid called with the WNOHANG option
S socket
T False
=-=-=-=-=-=
4. Assembly and Data Structures
A 1
B int
C void func(int x) {
	int y = 0;
	if (x == 0)
		return;
	
	do {
		y += 1;
		y = y * x;
	} while (y % 2 != 0);

	return;
 }
=-=-=-=-=-=
5. Memory and Pointers
ll_node *findelement(void *region, struct ll_node *list, int value) {
	addr = region;
	while (true) {
		if (list->r_next != NULL) {
			if (list->value == value)
				return &list;
			else
				list = list->r_next;
				addr += sizeof(off_t);
		} else {
			return ll_node* NULL;
		}
	}
}

=-=-=-=-=-=
6. Teensy OS VM System
A 16
B 4
C Larger
D 0xFF
E van = vaddr >> 8 
F The present bit is not set for the pages that are ending up in the exception handler.
G You are trying to access pages that are not allowed to be touched by user processes.
H You may be trying to write to certain pages, and you unless you have both permission to access it from a user process and the ability to write, you will get a permission fault.
=-=-=-=-=-=
7. Teensy OS Page Tables
A Invalid page access
B Invalid page access
C 0xAB432
D Privilege violation
E 0x09876
F 0x92654
G Permission violation
H Privilege violation
=-=-=-=-=-=
8. Processes
A 1
B 2
C 1
D 2
E 2
F 3
=-=-=-=-=-=
9. Synchronization
A Counting Semaphore
B Mutex
C Binary Semaphore
D Counting Semaphore. Could have two semaphores, one would be used if readers are accessing resource to control the number of readers allowed to be actively reading. The other would be used if the writer is writing to only allow writer to access it.
E Starvation
F Deadlock
=-=-=-=-=-=
10. Be a CS61 TF!
A dup2(lastpipe[0], curpipe[0]); close(lastpipe[1]);
B dup2(curpipe[0], STDIN_FILENO); close(curpipe[1]);
C close(curpipe[1]);
=-=-=-=-=-=
11. Network Servers
A Memory for spinning up new threads or to fork processes, open files.
B To avoid blocking if someone launches a DOS attack on your server, you can use the select system call and the fcntl function to eliminate blocking while listening (achieved via implementing the fcntl function) and blocking while handling the connection (achieved when implementing the select system call). Additionally, you can efficiently close the connection for a client if there is no data by implementing fgetc so that it returns when there's no data.
C You can hit the limit in terms of memory available for creating new threads. At that point, you cannot keep creating new threads (depending on the velocity of the requests coming in, as in the case of the serviceblaster program in class).
D The server spins in a loop calling the accept() system call, to accept incoming connections from the internet. This blocks until a connection is received. Once a client wants to connect, the server returns a new file descriptor of the socket for the new connection. It then processes the connection (which can be handled on a separate thread) and then closes the client socket. The server can use a counting semaphore to only allow a fixed number of active threads processing connections so as to avoid overloading the server.
E connect, accept, listen, select (but select blocks until a timeout)
